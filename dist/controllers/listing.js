var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { validationResult, query } from 'express-validator';
import { supabase } from '../clients/supabase.js';
import cloudinaryV2 from '../clients/cloudinary.js';
import path from 'path';
import { uploadToCloudinary } from '../middlewares/preUpload.js';
export const postListing = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
    const { title, description, dailyPrice, location, category } = req.body;
    const numericPrice = Number(dailyPrice);
    // Check if conversion was successful
    if (isNaN(numericPrice)) {
        return void res.status(400).json({ error: 'Invalid price format' });
    }
    const supabaseData = {
        name: title,
        description: description,
        location: location,
        category: category,
        price: dailyPrice
    };
    const { error } = yield supabase
        .from('listings')
        .insert(supabaseData);
    if (error) {
        console.error(error);
    }
    ;
    return void res.status(200).json({
        message: 'Success!'
    });
});
export const uploadListingMedia = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
    yield query('listingId').isString().escape().run(req);
    yield query('type').isString().escape().run(req);
    const { listingId, type } = req.query;
    try {
        if (!type || typeof type !== 'string') {
            return void res.status(400).json({ message: 'Type parameter is required and must be a string' });
        }
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return void res.status(400).json({ errors: errors.array() });
        }
        const reviewTypes = {
            'tools': 'tools',
            'city': 'Cities',
            'activity': 'Activities',
            'landmark': 'Landmarks',
            'restaurant': 'Restaurants',
            'dish': 'Dishes',
            'outdoor': 'Outdoors',
        };
        function processFile(file, folder, listingId, newMedias) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                const oldPublicId = file.filename;
                const newPublicId = `${folder}/${listingId}/${path.basename(file.originalname, path.extname(file.originalname))}`;
                try {
                    let mediaType = '';
                    if (file.mimetype.startsWith('image/')) {
                        mediaType = 'image';
                    }
                    else if (file.mimetype.startsWith('video/')) {
                        mediaType = 'video';
                    }
                    else {
                        return;
                    }
                    let autoGeneratedTags = ['Image']; // Default tag
                    if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
                        autoGeneratedTags = file.tags;
                    }
                    const result = yield cloudinaryV2.uploader.rename(oldPublicId, newPublicId, { resource_type: mediaType });
                    if (result) {
                        newMedias.push({
                            media: result.url,
                            publicId: newPublicId,
                            mediaType,
                            tags: autoGeneratedTags,
                            width: (_b = (_a = result.width) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
                            height: (_d = (_c = result.height) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''
                        });
                    }
                }
                catch (error) {
                    console.log(error);
                }
            });
        }
        const tableTypes = {
            'country': 'countries',
            'city': 'cities',
            'activity': 'activities',
            'landmark': 'landmarks',
            'restaurant': 'restaurants',
            'dish': 'dishes',
            'outdoor': 'outdoors',
        };
        const uploadTypes = {
            'tools': 'tools',
            'city': 'city_images',
            'activity': 'activity_images',
            'landmark': 'landmark_images',
            'restaurant': 'restaurant_images',
            'dish': 'dish_images',
            'outdoor': 'outdoor_images',
        };
        if (!reviewTypes[type]) {
            return void res.status(400).json({ message: 'Invalid type!' });
        }
        if (!uploadTypes[type]) {
            return void res.status(400).json({ message: 'Invalid review type!' });
        }
        // Verify listing exists
        const { data: currentListing, error: fetchError } = yield supabase
            .from('listings')
            .select('*')
            .eq('id', listingId)
            .single();
        if (fetchError || !currentListing) {
            console.log(fetchError);
            return void res.status(404).json({ message: 'Listing not found!' });
        }
        const folder = reviewTypes[type];
        const newMedias = [];
        if (!req.files || !Array.isArray(req.files)) {
            return void res.status(400).json({ message: 'No files uploaded!' });
        }
        // First upload files to temporary location, then process them
        const tempFiles = [];
        for (let file of req.files) {
            try {
                const result = yield uploadToCloudinary(file.buffer, file.originalname);
                // Create a file object that matches what processFile expects
                const tempFile = {
                    filename: result.public_id,
                    originalname: file.originalname,
                    mimetype: file.mimetype,
                    tags: result.tags || ['Image']
                };
                tempFiles.push(tempFile);
            }
            catch (uploadError) {
                console.error('Error uploading file to Cloudinary:', uploadError);
                return void res.status(500).json({ message: 'Failed to upload file to Cloudinary' });
            }
        }
        // Now process the uploaded files using your existing processFile function
        for (let file of tempFiles) {
            yield processFile(file, folder, listingId, newMedias);
        }
        if (newMedias.length === 0) {
            return void res.status(400).json({ message: 'No valid media files were processed' });
        }
        // Insert media records into database
        for (let media of newMedias) {
            const { error: insertError } = yield supabase
                .from('media')
                .insert({
                url: media.media,
                public_id: media.publicId,
                media_type: media.mediaType,
                score: 1,
                listing_id: listingId,
                category: folder,
                alt: media.tags.join(', '),
                width: media.width,
                height: media.height,
                type: type
            });
            if (insertError) {
                console.error('Database insert error:', insertError);
                return void res.status(500).json({ message: 'Failed to save media to database' });
            }
        }
        return void res.status(200).json({
            message: 'Posted!',
            uploadedCount: newMedias.length
        });
    }
    catch (error) {
        console.error('Upload error:', error);
        return void res.status(500).json({ message: 'Upload failed' });
    }
});
function processFile(file, folder, listingId, newMedias) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        const oldPublicId = file.filename;
        const newPublicId = `${folder}/${listingId}/${path.basename(file.originalname, path.extname(file.originalname))}`;
        try {
            let mediaType = '';
            if (file.mimetype.startsWith('image/')) {
                mediaType = 'image';
            }
            else if (file.mimetype.startsWith('video/')) {
                mediaType = 'video';
            }
            else {
                return;
            }
            let autoGeneratedTags = ['Image']; // Default tag
            if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
                autoGeneratedTags = file.tags;
            }
            const result = yield cloudinaryV2.uploader.rename(oldPublicId, newPublicId, { resource_type: mediaType });
            if (result) {
                newMedias.push({
                    media: result.url,
                    publicId: newPublicId,
                    mediaType,
                    tags: autoGeneratedTags,
                    width: (_b = (_a = result.width) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
                    height: (_d = (_c = result.height) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''
                });
            }
        }
        catch (error) {
            console.log(error);
        }
    });
}
const deleteTemporaryFolder = (sessionFolder) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield cloudinaryV2.api.delete_folder(sessionFolder);
        console.log(`Successfully deleted temporary folder: ${sessionFolder}`);
    }
    catch (error) {
        console.error(`Failed to delete temporary folder: ${error}`);
    }
});
