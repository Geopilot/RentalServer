import { check, validationResult, query } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import { supabase } from '../clients/supabase';
import { UploadApiResponse } from 'cloudinary';
import cloudinaryV2 from '../clients/cloudinary';
import path from 'path';
import { uploadToCloudinary } from '../middlewares/preUpload';

export const postListing = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { title, description, dailyPrice, location, category } = req.body;
    const numericPrice = Number(dailyPrice);
    // Check if conversion was successful
    if (isNaN(numericPrice)) {
        return void res.status(400).json({ error: 'Invalid price format' });
    }

    const supabaseData = {
        name: title,
        description: description,
        location: location,
        category: category,
        price: dailyPrice
    };

    const { error } = await supabase
        .from('listings')
        .insert(supabaseData)

    if (error) {
        console.error(error)
    };

    return void res.status(200).json({
        message: 'Success!'
    })
};

export const uploadListingMedia = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    await query('listingId').isString().escape().run(req);
    await query('type').isString().escape().run(req);

    const { listingId, type } = req.query;

    try {
        if (!type || typeof type !== 'string') {
            return void res.status(400).json({ message: 'Type parameter is required and must be a string' });
        }

        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return void res.status(400).json({ errors: errors.array() });
        }

        const reviewTypes: Record<string, string> = {
            'tools': 'tools',
            'city': 'Cities',
            'activity': 'Activities',
            'landmark': 'Landmarks',
            'restaurant': 'Restaurants',
            'dish': 'Dishes',
            'outdoor': 'Outdoors',
        };

        async function processFile(file: any, folder: string, listingId: string, newMedias: any[]) {
            const oldPublicId = file.filename;
            const newPublicId = `${folder}/${listingId}/${path.basename(file.originalname, path.extname(file.originalname))}`;
            try {
                let mediaType = '';
                if (file.mimetype.startsWith('image/')) {
                    mediaType = 'image';
                } else if (file.mimetype.startsWith('video/')) {
                    mediaType = 'video';
                } else {
                    return;
                }
                let autoGeneratedTags = ['Image']; // Default tag
                if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
                    autoGeneratedTags = file.tags;
                }

                const result: UploadApiResponse | undefined = await cloudinaryV2.uploader.rename(oldPublicId, newPublicId, { resource_type: mediaType });

                if (result) {
                    newMedias.push({
                        media: result.url,
                        publicId: newPublicId,
                        mediaType,
                        tags: autoGeneratedTags,
                        width: result.width?.toString() ?? '',
                        height: result.height?.toString() ?? ''
                    });
                }
            } catch (error) {
                console.log(error)
            }
        }

        const tableTypes: Record<string, string> = {
            'country': 'countries',
            'city': 'cities',
            'activity': 'activities',
            'landmark': 'landmarks',
            'restaurant': 'restaurants',
            'dish': 'dishes',
            'outdoor': 'outdoors',
        };

        const uploadTypes: Record<string, string> = {
            'tools': 'tools',
            'city': 'city_images',
            'activity': 'activity_images',
            'landmark': 'landmark_images',
            'restaurant': 'restaurant_images',
            'dish': 'dish_images',
            'outdoor': 'outdoor_images',
        };

        if (!reviewTypes[type]) {
            return void res.status(400).json({ message: 'Invalid type!' });
        }
        if (!uploadTypes[type]) {
            return void res.status(400).json({ message: 'Invalid review type!' });
        }

        // Verify listing exists
        const { data: currentListing, error: fetchError } = await supabase
            .from('listings')
            .select('*')
            .eq('id', listingId)
            .single();

        if (fetchError || !currentListing) {
            console.log(fetchError)
            return void res.status(404).json({ message: 'Listing not found!' });
        }

        const folder = reviewTypes[type];
        const newMedias: { media: string; publicId: string; mediaType: string; tags: string[], width: string, height: string; }[] = [];

        if (!req.files || !Array.isArray(req.files)) {
            return void res.status(400).json({ message: 'No files uploaded!' });
        }

        // First upload files to temporary location, then process them
        const tempFiles = [];
        for (let file of req.files) {
            try {
                const result: any = await uploadToCloudinary(file.buffer, file.originalname);
                // Create a file object that matches what processFile expects
                const tempFile = {
                    filename: result.public_id,
                    originalname: file.originalname,
                    mimetype: file.mimetype,
                    tags: result.tags || ['Image']
                };
                tempFiles.push(tempFile);
            } catch (uploadError) {
                console.error('Error uploading file to Cloudinary:', uploadError);
                return void res.status(500).json({ message: 'Failed to upload file to Cloudinary' });
            }
        }

        // Now process the uploaded files using your existing processFile function
        for (let file of tempFiles) {
            await processFile(file, folder, listingId as string, newMedias);
        }

        if (newMedias.length === 0) {
            return void res.status(400).json({ message: 'No valid media files were processed' });
        }

        // Insert media records into database
        for (let media of newMedias) {
            const { error: insertError } = await supabase
                .from('media')
                .insert({
                    url: media.media,
                    public_id: media.publicId,
                    media_type: media.mediaType,
                    score: 1,
                    listing_id: listingId,
                    category: folder,
                    alt: media.tags.join(', '),
                    width: media.width,
                    height: media.height,
                    type: type
                });

            if (insertError) {
                console.error('Database insert error:', insertError);
                return void res.status(500).json({ message: 'Failed to save media to database' });
            }
        }

        return void res.status(200).json({
            message: 'Posted!',
            uploadedCount: newMedias.length
        });

    } catch (error) {
        console.error('Upload error:', error);
        return void res.status(500).json({ message: 'Upload failed' });
    }
};

async function processFile(file: any, folder: string, listingId: string, newMedias: any[]) {
    const oldPublicId = file.filename;
    const newPublicId = `${folder}/${listingId}/${path.basename(file.originalname, path.extname(file.originalname))}`;
    try {
        let mediaType = '';
        if (file.mimetype.startsWith('image/')) {
            mediaType = 'image';
        } else if (file.mimetype.startsWith('video/')) {
            mediaType = 'video';
        } else {
            return;
        }
        let autoGeneratedTags = ['Image']; // Default tag
        if (file.tags && Array.isArray(file.tags) && file.tags.length > 0) {
            autoGeneratedTags = file.tags;
        }

        const result: UploadApiResponse | undefined = await cloudinaryV2.uploader.rename(oldPublicId, newPublicId, { resource_type: mediaType });

        if (result) {
            newMedias.push({
                media: result.url,
                publicId: newPublicId,
                mediaType,
                tags: autoGeneratedTags,
                width: result.width?.toString() ?? '',
                height: result.height?.toString() ?? ''
            });
        }
    } catch (error) {
        console.log(error)
    }
}


const deleteTemporaryFolder = async (sessionFolder: string) => {
    try {
        await cloudinaryV2.api.delete_folder(sessionFolder);
        console.log(`Successfully deleted temporary folder: ${sessionFolder}`);
    } catch (error) {
        console.error(`Failed to delete temporary folder: ${error}`);
    }
};
